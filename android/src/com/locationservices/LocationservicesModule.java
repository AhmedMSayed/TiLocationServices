/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2018 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.locationservices;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;

import org.appcelerator.titanium.TiApplication;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;

import java.util.HashMap;
import org.appcelerator.kroll.KrollFunction;
import java.util.Map;
import android.content.Intent;
import org.json.JSONObject;

import android.Manifest;

import android.content.pm.PackageManager;
import android.location.Location;

import android.support.annotation.NonNull;
import android.support.v4.content.ContextCompat;
import android.os.Bundle;

import android.content.IntentSender;

import com.google.android.gms.common.api.ResolvableApiException;
import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationCallback;
import com.google.android.gms.location.LocationRequest;
import com.google.android.gms.location.LocationResult;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.location.LocationSettingsRequest;
import com.google.android.gms.location.LocationSettingsResponse;
import com.google.android.gms.location.SettingsClient;
import com.google.android.gms.tasks.OnFailureListener;
import com.google.android.gms.tasks.OnSuccessListener;
import com.google.android.gms.tasks.Task;

@Kroll.module(name = "Locationservices", id = "com.locationservices")
public class LocationservicesModule extends KrollModule {

	private static final String LCAT = "LocationservicesModule";
	private static final boolean DBG = TiConfig.LOGD;

	private static FusedLocationProviderClient mFusedLocationClient;
	private static LocationRequest locationRequest;
	private static LocationCallback locationCallback;

	private final static int locationRequestCode = 1000;
	private final static int REQUEST_CHECK_SETTINGS = 0x1;
	private static final String TAG = null;

	public Double latitude;
	public Double longitude;

	public LocationservicesModule() {
		super();
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app) {
	}

	// Methods
	@Kroll.method
	public void initialize() {
		if (ContextCompat.checkSelfPermission(TiApplication.getAppRootOrCurrentActivity(),
				Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED
				&& ContextCompat.checkSelfPermission(TiApplication.getAppRootOrCurrentActivity(),
						Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
			// Permission is not granted
			Log.d(LCAT, "Allow ACCESS_FINE_LOCATION and ACCESS_COARSE_LOCATION permissions at runtime first");

		} else {
			mFusedLocationClient = LocationServices
					.getFusedLocationProviderClient(TiApplication.getAppRootOrCurrentActivity());

			locationRequest = LocationRequest.create();
			locationRequest.setInterval(10000);
			locationRequest.setFastestInterval(5000);
			locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);

			locationCallback = new LocationCallback() {
				@Override
				public void onLocationResult(LocationResult locationResult) {
					if (locationResult == null) {
						return;
					}
					for (Location location : locationResult.getLocations()) {
						if (location != null) {
							onLocation(location.getLatitude(), location.getLongitude());
							stopLocationUpdates();
						}
					}
				}
			};

			startLocationUpdates();

			LocationSettingsRequest.Builder builder = new LocationSettingsRequest.Builder()
					.addLocationRequest(locationRequest);
			builder.setAlwaysShow(true);

			SettingsClient client = LocationServices.getSettingsClient(TiApplication.getAppRootOrCurrentActivity());
			Task<LocationSettingsResponse> task = client.checkLocationSettings(builder.build());

			task.addOnSuccessListener(TiApplication.getAppRootOrCurrentActivity(),
					new OnSuccessListener<LocationSettingsResponse>() {
						@Override
						public void onSuccess(LocationSettingsResponse locationSettingsResponse) {
							Log.d(LCAT, "Location Settings are satisfied");
							lastLocation();
						}
					});

			task.addOnFailureListener(TiApplication.getAppRootOrCurrentActivity(), new OnFailureListener() {
				@Override
				public void onFailure(@NonNull Exception e) {
					if (e instanceof ResolvableApiException) {
						// Location settings are not satisfied, but this can be fixed
						// by showing the user a dialog.
						try {
							// Show the dialog by calling startResolutionForResult(),
							// and check the result in onActivityResult().
							Log.d(LCAT, "Location Settings are not satisfied, setting dialog going to show now");
							ResolvableApiException resolvable = (ResolvableApiException) e;
							resolvable.startResolutionForResult(TiApplication.getAppRootOrCurrentActivity(),
									REQUEST_CHECK_SETTINGS);
						} catch (IntentSender.SendIntentException sendEx) {
							// Ignore the error.
						}
					}
				}
			});
		}
	}

	private void lastLocation() {
		mFusedLocationClient.getLastLocation().addOnSuccessListener(TiApplication.getAppRootOrCurrentActivity(),
				new OnSuccessListener<Location>() {
					@Override
					public void onSuccess(Location location) {
						// Got last known location. In some rare situations this can be null.
						if (location != null) {
							onLocation(location.getLatitude(), location.getLongitude());
						}
					}
				});
	}

	public void onLocation(Double latitude, Double longitude) {
		try {
			if (hasListeners("location")) {
				KrollDict data = new KrollDict();
				data.put("latitude", latitude);
				data.put("longitude", longitude);
				fireEvent("location", data);
			}
		} catch (Exception e) {
			Log.e(LCAT, "Can't get Location: " + e.getMessage());
		}
	}

	private void startLocationUpdates() {
		mFusedLocationClient.requestLocationUpdates(locationRequest, locationCallback, null);
	}

	private void stopLocationUpdates() {
		mFusedLocationClient.removeLocationUpdates(locationCallback);
	}
}
